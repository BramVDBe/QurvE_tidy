---
title: "Quantitiative Fluorescence Curve Evaluation with Package `QurvE`"
author: "Nicolas T. Wirth"
date: "`r Sys.Date()`"
mainfont: Arial
output:
  prettydoc::html_pretty:
    fig_caption: yes
    toc: true
    theme: "cayman"
    highlight: vignette
vignette: >
  %\VignetteIndexEntry{Quantitiative Fluorescence Curve Evaluation with Package `QurvE`}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
csl: https://raw.githubusercontent.com/citation-style-language/styles/master/research-institute-for-nature-and-forest.csl
link-citations: true
lang: en-US
zotero: true
bibliography: references.bib
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(tidy.opts = list(width.cutoff = 60),
                      collapse = TRUE,
                      comment = "#>",
                      dev = 'png',
                      fig.path = "vigfig-")
knit_table <- function(df, caption){
  if (knitr::is_latex_output()) {
    for(i in 1:ncol(df)){
       df[,i] <- gsub("`", "$", arguments[,i])
     }
     df %>% knitr::kable("latex", linesep = "\\addlinespace", col.names = NULL, booktabs = TRUE, escape = F) %>%
      kableExtra::kable_styling(full_width = F, latex_options = "HOLD_position") %>% kableExtra::column_spec(column=1, width = "3cm") %>% kableExtra::column_spec(column=2, width = "14cm",)
  } else {
    table.formatted <- knitr::kable(df, escape = FALSE, row.names = F, col.names = NULL, format = "html", ) %>% kableExtra::column_spec(column=1, width = "3cm")
    for(i in 1:nrow(df)){
      table.formatted <- table.formatted %>% kableExtra::row_spec(i, extra_css = 'vertical-align: top !important; ')
    }
    table.formatted
   }
}
colorize <- function(x, color) {
  if (knitr::is_latex_output()) {
     sprintf("\\textcolor{%s}{%s}", color, x)
   } else {
    sprintf("<span style='color: %s;'>%s</span>", color,
            x)
   }
}
colorize_code <- function(x, color) {
    if (knitr::is_latex_output()) {
         sprintf("\\texttt{\\textcolor{%s}{%s}}", color, x)
    } else if (knitr::is_html_output()) {
        sprintf("<span style='color: %s;'>`%s`</span>", color,
                x)
    }
}
library(QurvE)
```

```{=latex}
\definecolor{codegray}{HTML}{efefef}
\let\textttOrig\texttt
\renewcommand{\texttt}[1]{\textttOrig{\colorbox{codegray}{#1}}}
```
<strong>Please note:</strong> This vignette will be updated from time to time when new features are implemented. Please find the most recent version at the [QurvE GitHub repository](https://github.com/NicWir/QurvE).

# Introduction

For a general introduction to the package, see the vignette *Quantitiative Growth Curve Evaluation with Package `QurvE`*. This vignette will show you how to use `QurvE` to analyze datasets with fluorescence measurements taken over time, as well as how to extract the most important results.

Fluorescent reporter proteins are widely used to study the mechanisms of gene regulation or to develop biosensors that allow the detection of chemical compounds and provide insights into the intracellular environment. A workflow for analyzing fluorescence data works analogously to analyzing growth data by following the scheme *read data* and *execute workflow*. The package allows users to select either time or growth data (e.g. from the simultaneous measurement of cell density and fluorescence intensity in plate reader experiments) as the independent variable. Additionally, biosensors can be characterized via dose-response analysis.

# Fluorescence profiling methods

`QurvE` offers the same curve evaluation methods for fluorescence data as for growth data, with the exception of fitting growth models. The calculation algorithms for *linear regression* and *nonparametric fits* (smoothing splines) as well as the default parameters have been empirically adjusted to account for the differences in curve shapes commonly seen with fluorescence data.

# Dose-response analysis methods

Dose response analysis is a useful method for evaluating the performance of a biosensor. Biosensors are typically designed to respond to specific chemical compounds, and the strength of the response often depends on the concentration of the target compound. Dose-response analysis can be used to determine the concentration of a target compound that elicits a half-maximal response in the biosensor (variants), the half-maximal effective concentration (EC~50~). This allows evaluation of the *sensitivity* and *specificity* of a biosensor and can be used to optimize the design for a particular application. In addition to evaluating the performance of biosensors, dose-response analysis can also be used to study the mechanisms of gene regulation in biological systems. By measuring the response of a biological system to different concentrations of a chemical compound, researchers can gain insights into the genes and pathways involved in the response, and can identify potential targets for drug discovery. `QurvE` provides two methods to perform dose-response analyses on fluorescence data:

1.  Perform a smooth spline fit on response vs. concentration data and extract the *EC~50~* as the concentration at the midpoint between the largest and smallest response value.

2.  Apply a biosensor response model to response vs. concentration data [@meyer2019].

# Run a complete fluorescence analysis workflow

Load the package:

```{r library-QurvE, echo = T, eval = TRUE, results='hide', message=FALSE, error=FALSE, warning=FALSE}
library(QurvE)
```

Next, load your experimental data. In this example, the dataset being used is from a preliminary characterization of different versions of the SEVA (Standard European Vector Architecture) plasmid pSEVA634, as described in [@nikel2022]. The data contains both growth an fluorescence measurements that have been converted into the custom `QurvE` data format and are located in different work sheets of the same XLSX file:

## Load data

```{r load-data, echo = T, eval = T, results='hide', message=FALSE, error=FALSE, warning=FALSE, tidy = TRUE}
input <- read_data(data.growth = system.file('lac_promoters.xlsx', package = 'QurvE'), sheet.growth = 1,
                   data.fl = system.file('lac_promoters.xlsx', package = 'QurvE'), sheet.fl = 2,
                   fl.normtype = "growth") # normalize fluorescence to growth data
```

The two functions `read_data()` or `parse_data()` come with more arguments to give the user more control when loading fluorescence data. As for growth data, arguments `r colorize_code("data.fl", "red")` (file path), `r colorize_code("csvsep.fl", "red")` (separator symbol in CSV file), `r colorize_code("dec.fl", "red")` (decimal separator), and `r colorize_code("sheet.fl", "red")` (Excel file worksheet number or "name") provide details on how where an how the data is stored. `r colorize_code("calib.fl", "red")` allows defining an equation with which to transform fluorescence values. 

Similarly, the functions accept the arguments `r colorize_code("data.fl2", "red")`, `r colorize_code("csvsep.fl2", "red")`, `r colorize_code("dec.fl2", "red")`, `r colorize_code("sheet.fl2", "red")`, and `r colorize_code("calib.fl2", "red")` to load data from a second fluorescence channel. This second fluorescence is currently only used to normalize the first fluorescence values, as applied in ...ADD CITATION... 

Normalization of fluorescence, if any, can be controlled via `r colorize_code("fl.normtype", "red")` to be performed by either dividing by growth values (`r colorize_code("fl.normtype = 'growth'", "red")`) or fluorescence 2 `r colorize_code("fl.normtype = 'fl2'", "red")`.

We can inspect the `input` object of class `grodata`:

```{r head-grodata, echo = T, eval = T}
head(input)
```

## Plot raw data

```{r raw-data-plot, dpi = 120, out.width="80%", fig.height=4.5, fig.pos = "H", echo = T, eval = T, results='hold', message=FALSE, error=FALSE, warning=FALSE, fig.cap = "\\label{fig:raw-data-plot} Raw data plot.\nConditions can be selected or deselected using the `names = c('grp1', 'grp2')` argument or `exclude.nm = c('grp3', 'grp4')` argument, respectively. Similarly, concentrations can be (de-selected) via the `conc` and `exclude.conc` arguments. To plot individual samples instead of grouping replicates, add `mean = FALSE`. See `?plot.grodata` for further options.", tidy = FALSE}
plot(input, data.type = "fl", 
     exclude.conc = c(0.5, 0.1),
     log.y = FALSE,
     legend.position = "bottom",
     basesize = 10, 
     legend.ncol = 3, 
     lwd = 0.7)
```

## Run Workflow

```{r run-default-workflow, message=T, error=FALSE, warning=FALSE, tidy.opts=list(width.cutoff=60), tidy = TRUE, eval = T}
grofit <- fl.workflow(grodata = input,
                          fit.opt = c("s", "l"),
                          ec50 = T,
                          suppress.messages = TRUE,
                          export.res = F) # Prevent creating TXT table and RData files with results
```

Tab-delimited .txt files summarizing the computation results are created automatically, as well as the `grofit` object (an object of class `grofit`) as .RData file. This object (or the .RData file) contains all raw data, fitting options, and computational results. Figure \@ref(fig:grofit-container) shows the structure of the generated `grofit`object. In RStudio, `View(grofit)` allows interactive inspection of the data container.

If you want to create a report summarizing all computational results including a graphical representation of every fit, provide the desired output format(s) as `r colorize_code("report = 'pdf'", "red")`, `r colorize_code("report = 'html'", "red")`, or `r colorize_code("report = c('pdf', 'html')", "red")`. The advantage of having the report in HTML format is that every figure can be exported as (editable) PDF file.

*`r colorize("In the spirit of good scientific practice (data transparency), I would encourage anyone using QurvE to attach the .RData file and generated reports to their publication.", "orange")`*

Arguments that are commonly modified:

```{r workflow-arguments, echo = F}
if (knitr::is_html_output()) {
  arguments <- data.frame(args = c("<span style='color: red;'>`fit.opt`</span>",
                                   "<span style='color: red;'>`model.type`</span>",
                                   "<span style='color: red;'>`log.y.lin`</span>\n<span style='color: red;'>`log.y.spline`</span>\n<span style='color: red;'>`log.y.model`</span>",
                                 "<span style='color: red;'>`biphasic`</span>",
                                 "<span style='color: red;'>`interactive`</span>",
                                 "<span style='color: red;'>`nboot.gc`</span>",
                                 "<span style='color: red;'>`dr.method`</span>",
                                 "<span style='color: red;'>`dr.parameter`</span>"),
                          descr = c("Which growth fitting methods to perform; a string containing `'l'` for linear fits, `'s'` for spline fits, `'m'` for model fits, or `'a'`(the default) for all three methods. Combinations can be also given as a vector of strings, e.g., `c('l', 's').`",
                                    "Which growth models to apply; a string containing one of, or a vector of strings containing any combination of 'logistic', 'richards', 'gompertz', 'gompertz.exp', 'huang', and 'baranyi'.",
                                    "Should Ln(y/y0) be applied to the growth data for the respective fits?",
                                    "Extract growth parameters for two different growth phases (as observed with, e.g., diauxic shifts)",
                                    "Controls interactive mode.  If `TRUE`, each fit is visualized in the Plots pane and the user can adjust fitting parameters and confirm the reliability of each fit per sample",
                                    "Number of bootstrap samples used for nonparametric growth curve fitting. See `?growth.gcBootSpline` for details.",
                                    "Define the method used to perform a dose-responde analysis: smooth spline fit (`'spline'`) or model fitting (`'model'`, the default). See section 4",
                                    "The response parameter in the output table to be used for creating a dose response curve. See `?growth.drFit` for further details."
                          ))

} else {
  arguments <- data.frame(args = c("\\texttt{\\textcolor{red}{fit.opt}}",
                                   "\\texttt{\\textcolor{red}{model.type}}",
                                   "\\texttt{\\textcolor{red}{log.y.lin}}\n\\texttt{\\textcolor{red}{log.y.spline}}\n\\texttt{\\textcolor{red}{log.y.model}}",
                                   "\\texttt{\\textcolor{red}{biphasic}}",
                                   "\\texttt{\\textcolor{red}{interactive}}",
                                   "\\texttt{\\textcolor{red}{nboot.gc}}",
                                   "\\texttt{\\textcolor{red}{dr.method}}",
                                   "\\texttt{\\textcolor{red}{dr.parameter}}"),
                          descr = c("Which growth fitting methods to perform; a string containing \\texttt{\\textcolor{red}{'l'}} for linear fits, \\texttt{\\textcolor{red}{'s'}} for spline fits, \\texttt{\\textcolor{red}{'m'}} for model fits, or \\texttt{\\textcolor{red}{'a'}}(the default) for all three methods. Combinations can be also given as a vector of strings, e.g., \\texttt{\\textcolor{red}{c('l', 's').}}",
                                    "Which growth models to apply; a string containing one of, or a vector of strings containing any combination of 'logistic', 'richards', 'gompertz', 'gompertz.exp', 'huang', and 'baranyi'.",
                                    "Should Ln(y/y0) be applied to the growth data for the respective fits?",
                                    "Extract growth parameters for two different growth phases (as observed with, e.g., diauxic shifts)",
                                    "Controls interactive mode.  If \\texttt{\\textcolor{red}{TRUE}}, each fit is visualized in the Plots pane and the user can adjust fitting parameters and confirm the reliability of each fit per sample",
                                    "Number of bootstrap samples used for nonparametric growth curve fitting. See \\texttt{?growth.gcBootSpline} for details.",
                                    "Define the method used to perform a dose-responde analysis: smooth spline fit (\\texttt{\\textcolor{red}{'spline'}}) or model fitting (\\texttt{\\textcolor{red}{'model'}}, the default). See section 4",
                                    "The response parameter in the output table to be used for creating a dose response curve. See \\texttt{?growth.drFit} for further details."
                          ))
}

knit_table(arguments)
```

\
Please consult `?growth.workflow` for further arguments to customize the workflow.\
\

```{r grofit-container, echo = FALSE, fig.pos = "H", out.width = "90%", fig.cap = "\\label{fig:grofit-container} Internal structure of a `grofit`object generated by `growth.workflow()`.", fig.align='center'}
knitr::include_graphics("../man/figures/grofit_container.jpg", error = F)
```

\pagebreak

## Tabular results

A `grofit` object contains two tables summarizing the computational results: - `grofit$gcFit$gcTable` lists all calculated physiological parameters for every sample and fit - `grofit$drFit$drTable` contains the results of the dose-response analysis

```{r echo = T, eval = T, results='asis', message=FALSE, error=FALSE, warning=FALSE, tidy = FALSE}
# show the first three rows and first 14 columns of gcTable
gcTable <- grofit$gcFit$gcTable
gcTable[1:3, 1:14]

# Show drTable. The function as.data.frame() ensures that it is shown in table format.
drTable <- as.data.frame(grofit$drFit$drTable)
```

Additionally, the dedicated functions `table_group_growth_linear()`, `table_group_growth_model()`, and `table_group_growth_spline()` allow the generation of grouped results tables for each of the three fit types with averages and standard deviations. The column headers in the resulting data frames are formatted with HTML for visualization in shiny and with `DT::datatable()`.

A summary of results for each individual fit can be obtained by applying the generic function `summary()` to any fit object within `grofit`.

## Visualize results

Several generic `plot()` methods have been written to allow easy plotting of results by merely accessing list items within the `grofit` object structure (Figure \@ref(fig:grofit-container)).

### Grouped spline fits

Applying `plot()` to the `grofit` object produces a figure of all spline fits performed as well as the first derivative (slope) over time. The generic function calls `plot.grofit()` with `data.type = 'spline'` and thus, the same options are available as described for Figure \@ref(fig:raw-data-plot).

```{r group-spline-plot, dpi = 120, out.width="80%", fig.height=6.5, fig.pos = "H", echo = T, eval = T, results='hide', message=FALSE, error=FALSE, warning=FALSE, fig.cap = "\\label{fig:group-spline-plot} Combined plot of all spline fits performed.\nIn addition to the options available with `data.type = 'raw'`, further arguments can be defined that control the appearance of the secondary panel showing the slope over time. See `?plot.grofit` for all options.", tidy = FALSE}
plot(grofit,
     data.type = "spline",
     log.y = TRUE,
     conc = c(0,5,10,15,20),
     legend.position = "right",
     legend.ncol = 1,
     x.lim = c(NA, 32),
     y.lim = c(0.01,NA),
     n.ybreaks = 10,
     basesize=10,
     lwd = 0.7)
```

\pagebreak

### Compare growth parameters

A convenient way to compare the performance of different organisms under different conditions is to plot the calculated growth parameters by means of the function `plot.parameter()`.

```{r plot-parameter, dpi = 120, fig.show="hold", out.width="47%", fig.height = 4, results='hold' ,fig.align="center", fig.pos = "H", echo = T, eval = T, message=FALSE, error=FALSE, warning=FALSE, tidy = TRUE, fig.cap = "\\label{fig:plot-parameter} Parameter plots. If `mean = TRUE`, the results of replicates are combined and shown as their mean \u00B1 95\\% confidence interval. As with the functions for combining different growth curves, the arguments `name`, `exclude.nm`, `conc` and `exclude.conc` allow (de)selection of specific samples or conditions. Since we applied growth models to log-transformed data, calling 'dY.orig.model' or 'A.orig.model' instead of 'dY.model' or 'A.model' provides the respective values on the original scale. For linear and spline fits, this is done automatically. For details about this function, run `?plot.parameter`."}
# Parameters obtained from linear regression
plot.parameter(grofit, param = "mu.linfit", basesize = 10, legend.position = "bottom")
plot.parameter(grofit, param = "dY.linfit", basesize = 10, legend.position = "bottom")

# Parameters obtained from nonparametric fits
plot.parameter(grofit, param = "mu.spline", basesize = 10, legend.position = "bottom")
plot.parameter(grofit, param = "dY.spline", basesize = 10, legend.position = "bottom")

# Parameters obtained from model fits
plot.parameter(grofit, param = "mu.model", basesize = 10, legend.position = "bottom")
plot.parameter(grofit, param = "dY.orig.model", basesize = 10, legend.position = "bottom")
```

From the parameter plot for ´mu.linfit´ (the growth rates determined with linear regression), we can see that there is an outlier for strain KT2440 at concentration 0. We can plot the individual fits for this condition to find out if this is due to the fit quality:

```{r plot-linear, dpi = 120, fig.ncol = 1, fig.show="hold", out.width="70%", fig.height = 4.5, fig.pos = "H", fig.align='left', echo = T, eval = T, message=FALSE, error=FALSE, warning=FALSE, tidy = TRUE, fig.cap = "\\label{fig:plot-linear} Linear fit plots to identify sample outliers. For details about this function, run `?plot.gcFitLinear`.", fig.subcap=c("Sample 'KT2440 | 1 | 0'", "Sample 'KT2440 | 2 | 0'")}
plot(grofit$gcFit$gcFittedLinear$`KT2440 | 1 | 0`, cex.lab = 1.2, cex.axis = 1.2)
plot(grofit$gcFit$gcFittedLinear$`KT2440 | 2 | 0`, cex.lab = 1.2, cex.axis = 1.2)
```

Apparently, the algorithm to find the maximum slope in the growth curve with the standard threshold of `lin.R2 = 0.97` could not find an appropriate fit within the first stage of growth due to insufficient linearity. We can manually re-run the fit for this sample with adjusted parameters. Thereby, we lower the R2 threshold and increase the size of the sliding window to cover a larger fraction of the growth curve. Then, we update the respective entries in the `gcTable` object that summarizes all fitting results (and that plot.parameter() accesses to extract relevant data). The generic function `summary()`, when applied to a the fit object of a single sample within `grofit`, provides the required parameters to update the table. Lastly, we also have to re-run the dose-response analysis since 'mu.linfit' was used as response parameter (the default), including the erroneous value.

*Note: This process of manually updating `grofit`elements with adjusted fits can be avoided by re-running `growth.workflow` with adjusted global parameters or my running the workflow in interactive mode (`interactive = TRUE`). In interactive mode, each individual fit is printed and the user can decide to re-run a single fit with adjusted parameters.*

```{r message=T, error=FALSE, warning=FALSE, tidy.opts=list(width.cutoff=60), tidy = FALSE, eval = T}
# Replace the existing linear fit entry for sample `KT2440 | 2 | 0`
# with a new fit
grofit$gcFit$gcFittedLinear$`KT2440 | 2 | 0` <-
  growth.gcFitLinear(time = grofit$gcFit$gcFittedLinear$`KT2440 | 2 | 0`$raw.time,
                     data = grofit$gcFit$gcFittedLinear$`KT2440 | 2 | 0`$raw.data,
                     control = growth.control(lin.R2 = 0.90, lin.h = 12))

# extract row index of sample `KT2440 | 2 | 0`
ndx.row <- grep("KT2440 \\| 2 \\| 0", grofit$expdesign$label)

# get column indices of linear fit parameters (".linfit")
ndx.col <- grep("\\.linfit", colnames(grofit$gcFit$gcTable) )

# Replace previous growth parameters stored in gcTable
grofit$gcFit$gcTable[ndx.row, ndx.col] <-
  summary(grofit$gcFit$gcFittedLinear$`KT2440 | 2 | 0`)

# Replace existing dose-response analysis with new fit
grofit$drFit <- growth.drFit(
  gcTable = grofit$gcFit$gcTable,
  control = grofit$control) # we can copy the control object from the original workflow.
```

And we can validate the quality of the updated fit:

```{r plot-linear-update, dpi = 120, fig.show="hold", out.width="70%", fig.height = 4.5, results='hold' ,fig.align="center", fig.pos = "H", echo = T, eval = T, message=FALSE, error=FALSE, warning=FALSE, tidy = TRUE, fig.cap = "\\label{fig:plot-linear-update} Updated linear fit for the outlier sample 'KT2440 | 2 | 0'."}
plot(grofit$gcFit$gcFittedLinear$`KT2440 | 2 | 0`, cex.lab = 1.2)
```

That looks better!

```{r plot-parameter-update, dpi = 120, out.width="70%", fig.height = 4, fig.align="center", fig.pos = "H", echo = T, eval = T, message=FALSE, error=FALSE, warning=FALSE, tidy = TRUE, fig.cap = "\\label{fig:plot-parameter-update} Parameter plot with updated fit."}
# Parameters obtained from linear regression
plot.parameter(grofit, param = "mu.linfit", basesize = 8.5)
```

### Dose-response analysis

The results of the dose-response analysis can be visualized by calling `plot()` on the `drFit` object that is stored within `grofit`. This action calls `plot.drFit()` which in turn runs `plot.drFitSpline()` or `plot.drFitModel()` (depending on the choice of `r colorize_code("dr.method", "red")` in the workflow) on every condition for which a dose-response analysis has been performed. Alternatively, you can call `plot()` on the list elements in `grofit$drFit$drFittedModels` or `grofit$drFit$drFittedSplines`, respectively.

```{r plot-drFit, dpi = 120, fig.ncol = 1, fig.show="hold", out.width="70%", fig.height = 4.5, fig.pos = "H", fig.align='center', echo = T, eval = T, message=FALSE, error=FALSE, warning=FALSE, tidy = TRUE, fig.cap = "\\label{fig:plot-drFit} Dose response analysis - model fits. For details about this function, run `?plot.drFit`."}
plot(grofit$drFit, cex.point = 1, basesize = 12)
```

# Bootstrapping

When growth experiments are performed on a larger scale with manual density measurements, technical deviations can result in outliers. Such outliers can lead to a distortion of the curve fits, especially if fewer data points are available than is usual in plate reading experiments. In this instance, bootstrapping can provide a more realistic estimation of growth parameters. Bootstrapping is a statistical procedure that resamples a single dataset to create many simulated samples. This is done by randomly drawing data points from a dataset with replacement until the original number of data points has been reached. The analysis (here: growth fitting) is then performed individually on each bootstrapped replicate. The variation in the resulting estimated parameters is a reasonable approximation of the variance in those parameters. To include bootstrapping into the `QurvE` workflow, we define the argument `r colorize_code("nboot.gc", "red")`.

Similarly, we can include bootstrapping in the dose-response analysis if done with `r colorize_code("dr.method = 'spline'", "red")` by defining argument `r colorize_code("nboot.dr", "red")`.

```{r run-workflow_with-bootstrapping, dpi = 120, message=T, error=FALSE, warning=FALSE, tidy.opts=list(width.cutoff=60), tidy = TRUE, eval = T}
grofit_bt <- growth.workflow(grodata = grodata,
                             fit.opt = "s", # perform only nonparametric growth fitting
                             nboot.gc = 50,
                             ec50 = T,
                             dr.method = "spline",
                             dr.parameter = "mu.spline",
                             nboot.dr = 50,
                             smooth.dr = 0.25,
                             suppress.messages = TRUE,
                             export.res = F)
```

To plot the results of a growth fit with bootstrapping, we call `plot()` on a `gcBootSpline` object:

```{r plot-gcBootSpline, dpi = 120, fig.show="hold", out.width="85%", fig.height = 8, fig.pos = "H", fig.align='center', echo = T, eval = T, message=FALSE, error=FALSE, warning=FALSE, tidy = TRUE, fig.cap = "\\label{fig:plot-gcBootSpline} Nonparametric growth fit with bootstrapping. For details about this function, run `?plot.gcBootSpline`."}
plot(grofit_bt$gcFit$gcBootSpline[[7]], # Double braces serve as an alternative to
                                        # access list items and allow their access by number
     combine = TRUE, # combine both growth curves and parameter plots in the same window
     lwd = 0.7)
```

And by applying `plot()` to a `drBootSpline` object, we can plot the dose-response bootstrap results:

```{r plot-drBootSpline, dpi = 120, fig.show="hold", out.width="85%", fig.height = 6, fig.pos = "H", fig.align='center', echo = T, eval = T, message=FALSE, error=FALSE, warning=FALSE, tidy = TRUE, fig.cap = "\\label{fig:plot-drBootSpline} Dose-response analysis with bootstrapping. For details about this function, run `?plot.drBootSpline`."}
plot(grofit_bt$drFit$drBootSpline[[1]],
     combine = TRUE, # combine both dose-response curves and parameter plots in the same window
     lwd = 0.7)
```

\pagebreak

# References

::: {#refs}
:::
